MODEL
-----

Variables
  Are either anonymous or named
  Named variables can be refered to accross predicate invocations
  Anonymous are, in particular, used for constants.


Solution 
  A series of templated classes needed (SolutionN, N=1,2,3,...)
  Are immutable, a predicate receives a Solution and produces a Solution
  Must be possible to represent "zero solution", different from "free"

  For every dimension, "Binding"
    - variable referred to
    - cardinality
    - list of values
    
  On SolutionN: obtain list of tuples, probably by cartesian product of Bindings


Predicates
  Are SAM classes with an apply() method
  The apply method takes into account arity of predicate, eg. range/3:
    Solution3<Integer, Integer, Integer> apply(Solution3<Integer, Integer, Integer>)

May need a Solution0 for predicates in the form pred/0

For N-ary predicates, such as and/* and or/*, we may need SolutionN



ALGORITHMS
----------

digit(X)  with X free
  
  Allocate inSol=Solution1(X), free
  invoke outSol=apply(inSol)
    apply "clones" inSol (ie Solution1(X))
    inSol is free, enter generative mode
    generate list of 0..9 into outSol
    return

digit(X)  with X bound to {3,4,100}
  Same as above, but
    inSol is not free, enter validation mode
    for every value in inSol, if the value is acceptable, copy to outSol
    (this yields: 3,4)
    return

range(A,B,X) with A=2, B=4 bound and X free
  Allocate inSol=Solution3(A,B,X) with 1 solution <2,4,null>
  invoke apply()
    apply "clones" inSol (ie Solution3(A,B,X))
    checks arguments: A and B are bound (OK) to one value (OK)
    X is free: enter generative mode
    generate list of A..B into outSol
    return

and(P1, P2)
  ? what should be the invoking Solution? SolutionN?
    -> SolutionN with as many public vars as found in all predicates
    -> what about nested and/or?
  ? what the resulting Solution? SolutionN?
    -> most probably yes, to extract all public vars
  invocation of P1
    allocate inSol as above
    invoke
  preparation of P2
    if any bound named var in P1 (or in previous outSol) appears in P2
      prepare an inSol for P2 with those vars of outSol(P*) bound
    
    otherwise
      allocate inSol as above
      invoke
  loop


